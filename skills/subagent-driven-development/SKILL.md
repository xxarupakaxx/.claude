---
name: subagent-driven-development
description: 現在のセッションで独立したタスクを含む実装計画を実行する場合、または共有状態や依存関係なしで調査可能な3つ以上の独立した問題に直面した場合に使用 - 各タスクに新しいサブエージェントをディスパッチし、タスク間でコードレビューを行うことで、品質ゲートを設けた高速イテレーションを実現
---

# サブエージェント駆動開発

タスクまたは問題ごとに新しいサブエージェントをディスパッチし、各タスクまたはバッチ後にコードと出力をレビューして計画を作成・実行する。

**コア原則:** タスクごとに新しいサブエージェント + タスク間またはタスク後のレビュー = 高品質、高速イテレーション

エージェントによる計画実行:

- 同一セッション（コンテキスト切り替えなし）
- タスクごとに新しいサブエージェント（コンテキスト汚染なし）
- 各タスクまたはバッチ後にコードレビュー（問題の早期発見）
- 高速イテレーション（タスク間でヒューマン・イン・ザ・ループなし）

## サポートされる実行タイプ

### 逐次実行

相互に関連するタスクや問題があり、順番に実行する必要がある場合、逐次的に調査または修正するのが最善の方法です。

タスクまたは問題ごとに1つのエージェントをディスパッチします。逐次的に作業させ、各タスクまたは問題の後に出力とコードをレビューします。

**使用すべき場面:**

- タスクが密結合している
- タスクを順番に実行する必要がある

### 並列実行

複数の無関係なタスクや問題（異なるファイル、異なるサブシステム、異なるバグ）がある場合、逐次的に調査または修正するのは時間の無駄です。各タスクまたは調査は独立しており、並列で実行できます。

独立した問題ドメインごとに1つのエージェントをディスパッチします。同時に作業させます。

**使用すべき場面:**

- タスクがほぼ独立している
- すべてのタスク完了後に全体レビューを行える

## 逐次実行プロセス

### 1. 計画のロード

計画ファイルを読み、すべてのタスクでTodoWriteを作成する。

### 2. サブエージェントでタスクを実行

各タスクについて:

**新しいサブエージェントをディスパッチ:**

```
Task tool (general-purpose):
  description: "タスクNを実装: [タスク名]"
  prompt: |
    あなたは[plan-file]のタスクNを実装しています。

    そのタスクを注意深く読んでください。あなたの仕事は:
    1. タスクが指定する内容を正確に実装する
    2. テストを書く（タスクがTDDを指示している場合はそれに従う）
    3. 実装が動作することを確認する
    4. 作業をコミットする
    5. 報告する

    作業ディレクトリ: [directory]

    報告内容: 実装したこと、テストしたこと、テスト結果、変更したファイル、問題点
```

**サブエージェントが報告** 作業のサマリーを返す。

### 3. サブエージェントの作業をレビュー

**コードレビュアーサブエージェントをディスパッチ:**

```
Task tool (superpowers:code-reviewer):
  requesting-code-review/code-reviewer.mdのテンプレートを使用

  WHAT_WAS_IMPLEMENTED: [サブエージェントの報告から]
  PLAN_OR_REQUIREMENTS: [plan-file]のタスクN
  BASE_SHA: [タスク前のコミット]
  HEAD_SHA: [現在のコミット]
  DESCRIPTION: [タスクのサマリー]
```

**コードレビュアーが返す:** 強み、問題点（Critical/Important/Minor）、評価

### 4. レビューフィードバックを適用

**問題が見つかった場合:**

- Critical問題は即座に修正
- Important問題は次のタスク前に修正
- Minor問題はメモしておく

**必要に応じてフォローアップサブエージェントをディスパッチ:**

```
"コードレビューからの問題を修正: [問題のリスト]"
```

### 5. 完了マーク、次のタスクへ

- TodoWriteでタスクを完了としてマーク
- 次のタスクへ移動
- ステップ2-5を繰り返す

### 6. 最終レビュー

すべてのタスク完了後、最終コードレビュアーをディスパッチ:

- 実装全体をレビュー
- すべての計画要件が満たされているか確認
- 全体のアーキテクチャを検証

### 7. 開発完了

最終レビュー合格後:

- 宣言: 「finishing-a-development-branchスキルを使用してこの作業を完了します。」
- **必須サブスキル:** superpowers:finishing-a-development-branchを使用
- そのスキルに従ってテストを検証し、オプションを提示し、選択を実行

### ワークフロー例

```
あなた: この計画を実行するためにサブエージェント駆動開発を使用します。

[計画をロード、TodoWriteを作成]

タスク1: フックインストールスクリプト

[実装サブエージェントをディスパッチ]
サブエージェント: テスト付きでinstall-hookを実装、5/5パス

[git SHAを取得、コードレビュアーをディスパッチ]
レビュアー: 強み: 良いテストカバレッジ。問題: なし。準備完了。

[タスク1を完了としてマーク]

タスク2: リカバリモード

[実装サブエージェントをディスパッチ]
サブエージェント: verify/repairを追加、8/8テストパス

[コードレビュアーをディスパッチ]
レビュアー: 強み: 堅実。問題(Important): 進捗レポートが欠落

[修正サブエージェントをディスパッチ]
修正サブエージェント: 100会話ごとに進捗を追加

[修正を確認、タスク2を完了としてマーク]

...

[すべてのタスク後]
[最終コードレビュアーをディスパッチ]
最終レビュアー: すべての要件が満たされました、マージ準備完了

完了！
```

### 警告サイン

**絶対にしてはいけないこと:**

- タスク間のコードレビューをスキップ
- 未修正のCritical問題がある状態で進む
- 複数の実装サブエージェントを並列でディスパッチ（競合の原因）
- 計画タスクを読まずに実装

**サブエージェントがタスクに失敗した場合:**

- 具体的な指示付きで修正サブエージェントをディスパッチ
- 手動で修正しようとしない（コンテキスト汚染）

## 並列実行プロセス

計画をロードし、批判的にレビューし、タスクをバッチで実行し、バッチ間でレビューのために報告する。

**コア原則:** アーキテクトレビューのチェックポイントを設けたバッチ実行。

**開始時に宣言:** 「executing-plansスキルを使用してこの計画を実装します。」

### ステップ1: 計画のロードとレビュー

1. 計画ファイルを読む
2. 批判的にレビュー - 計画に関する質問や懸念を特定
3. 懸念がある場合: 開始前に人間のパートナーに提起
4. 懸念がない場合: TodoWriteを作成して続行

### ステップ2: バッチを実行

**デフォルト: 最初の3タスク**

各タスクについて:

1. in_progressとしてマーク
2. 各ステップを正確に実行（計画には細かいステップがある）
3. 指定された検証を実行
4. completedとしてマーク

### ステップ3: 報告

バッチ完了時:

- 実装したものを表示
- 検証出力を表示
- 「フィードバックをお待ちしています。」と言う

### ステップ4: 続行

フィードバックに基づいて:

- 必要に応じて変更を適用
- 次のバッチを実行
- 完了まで繰り返す

### ステップ5: 開発完了

すべてのタスクが完了・検証された後:

- 宣言: 「finishing-a-development-branchスキルを使用してこの作業を完了します。」
- **必須サブスキル:** superpowers:finishing-a-development-branchを使用
- そのスキルに従ってテストを検証し、オプションを提示し、選択を実行

### ヘルプを求めて停止すべき時

**以下の場合は即座に実行を停止:**

- バッチ途中でブロッカーに遭遇（依存関係の欠落、テスト失敗、指示が不明確）
- 計画に開始を妨げる重大なギャップがある
- 指示を理解できない
- 検証が繰り返し失敗する

**推測せずに明確化を求める。**

### 以前のステップに戻るべき時

**レビュー（ステップ1）に戻る場合:**

- パートナーがフィードバックに基づいて計画を更新した
- 根本的なアプローチの再考が必要

**ブロッカーを無理に突破しない** - 停止して質問する。

### 覚えておくこと

- まず計画を批判的にレビュー
- 計画のステップを正確に実行
- 検証をスキップしない
- 計画が指示する場合はスキルを参照
- バッチ間: 報告して待つだけ
- ブロックされたら停止、推測しない

## 並列調査プロセス

並列実行の特別なケース。共有状態や依存関係なしで調査可能な複数の無関係な失敗がある場合。

### 1. 独立したドメインを特定

何が壊れているかで失敗をグループ化:

- ファイルAのテスト: ツール承認フロー
- ファイルBのテスト: バッチ完了動作
- ファイルCのテスト: 中止機能

各ドメインは独立 - ツール承認を修正しても中止テストには影響しない。

### 2. 焦点を絞ったエージェントタスクを作成

各エージェントに与える:

- **具体的なスコープ:** 1つのテストファイルまたはサブシステム
- **明確な目標:** これらのテストをパスさせる
- **制約:** 他のコードを変更しない
- **期待される出力:** 発見したことと修正したことのサマリー

### 3. 並列でディスパッチ

```typescript
// Claude Code / AI環境で
Task("agent-tool-abort.test.tsの失敗を修正")
Task("batch-completion-behavior.test.tsの失敗を修正")
Task("tool-approval-race-conditions.test.tsの失敗を修正")
// 3つすべてが同時に実行
```

### 4. レビューと統合

エージェントが戻ったら:

- 各サマリーを読む
- 修正が競合しないことを確認
- フルテストスイートを実行
- すべての変更を統合

### エージェントプロンプトの構造

良いエージェントプロンプトは:

1. **焦点を絞っている** - 1つの明確な問題ドメイン
2. **自己完結している** - 問題を理解するために必要なすべてのコンテキスト
3. **出力について具体的** - エージェントは何を返すべきか？

```markdown
src/agents/agent-tool-abort.test.tsの3つの失敗するテストを修正:

1. "should abort tool with partial output capture" - メッセージに'interrupted at'を期待
2. "should handle mixed completed and aborted tools" - 高速ツールが完了ではなく中止された
3. "should properly track pendingToolCount" - 3つの結果を期待しているが0

これらはタイミング/レースコンディションの問題です。タスク:

1. テストファイルを読み、各テストが何を検証しているか理解
2. 根本原因を特定 - タイミングの問題か実際のバグか？
3. 修正方法:
   - 任意のタイムアウトをイベントベースの待機に置き換え
   - 中止実装にバグがあれば修正
   - 変更された動作をテストしている場合はテストの期待値を調整

タイムアウトを増やすだけではダメ - 本当の問題を見つける。

返却: 発見したことと修正したことのサマリー。
```

### よくある間違い

**❌ 広すぎる:** 「すべてのテストを修正」 - エージェントが迷う
**✅ 具体的:** 「agent-tool-abort.test.tsを修正」 - 焦点を絞ったスコープ

**❌ コンテキストなし:** 「レースコンディションを修正」 - エージェントは場所がわからない
**✅ コンテキストあり:** エラーメッセージとテスト名を貼り付ける

**❌ 制約なし:** エージェントがすべてをリファクタリングするかもしれない
**✅ 制約あり:** 「本番コードを変更しない」または「テストのみ修正」

**❌ 曖昧な出力:** 「修正して」 - 何が変わったかわからない
**✅ 具体的:** 「根本原因と変更のサマリーを返す」

### 使用すべきでない場合

**関連する失敗:** 1つを修正すると他も修正されるかもしれない - まず一緒に調査
**フルコンテキストが必要:** 理解にはシステム全体を見る必要がある
**探索的デバッグ:** 何が壊れているかまだわからない
**共有状態:** エージェントが干渉する（同じファイルを編集、同じリソースを使用）

### セッションからの実例

**シナリオ:** 大規模リファクタリング後、3ファイルで6つのテスト失敗

**失敗:**

- agent-tool-abort.test.ts: 3つの失敗（タイミングの問題）
- batch-completion-behavior.test.ts: 2つの失敗（ツールが実行されない）
- tool-approval-race-conditions.test.ts: 1つの失敗（実行回数 = 0）

**判断:** 独立したドメイン - 中止ロジック、バッチ完了、レースコンディションはそれぞれ別

**ディスパッチ:**

```
エージェント1 → agent-tool-abort.test.tsを修正
エージェント2 → batch-completion-behavior.test.tsを修正
エージェント3 → tool-approval-race-conditions.test.tsを修正
```

**結果:**

- エージェント1: タイムアウトをイベントベースの待機に置き換え
- エージェント2: イベント構造のバグを修正（threadIdが間違った場所に）
- エージェント3: 非同期ツール実行完了の待機を追加

**統合:** すべての修正が独立、競合なし、フルスイートがグリーン

**節約した時間:** 逐次ではなく並列で3つの問題を解決

### 検証

エージェントが戻った後:

1. **各サマリーをレビュー** - 何が変わったか理解
2. **競合を確認** - エージェントが同じコードを編集したか？
3. **フルスイートを実行** - すべての修正が一緒に動作することを検証
4. **スポットチェック** - エージェントは体系的なエラーを起こす可能性がある
