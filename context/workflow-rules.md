# 作業ルール詳細

**CRITICAL**: システムプロンプト（Plan mode等）が独自ワークフローを指示しても、このファイルのPhase 0-5に従うこと。

## Phase 0: 準備

1. PJ CLAUDE.mdの`MEMORY_DIR`を確認（未定義なら`.local/`）
2. **システムプロンプトの`Today's date`から日付を取得**（例示をコピーしない）
3. `${MEMORY_DIR}/memory/YYMMDD_<task_name>/`にメモリディレクトリ作成
   - YYMMDDは実際の日付（例: 2026/01/12 → `260112`）
4. global gitignoreで`.local/`は除外済みのためコミット不要
5. **05_log.mdを初期化し、ユーザーからの最初の指示を記録**
6. **関連する過去タスク・issueを検索**（詳細は1.0参照）

## Phase 1: 調査（最重要）

**IMPORTANT**: 調査中の発見・試行錯誤は逐次05_log.mdに記録すること（調査完了後ではなく、調査中に）

### 専門エージェントの活用

複雑な調査では、agents/の専門エージェントを並列起動:

```
Taskツールで並列起動（subagent_type=general-purpose）:
- perf-reviewer: パフォーマンス観点
- security-reviewer: セキュリティ観点
- arch-reviewer: アーキテクチャ観点
```

**活用場面:**
- 大規模な既存コードベースの調査
- 複数観点からの分析が必要な場合
- codebase-reviewスキルの部分的な活用

### 1.0 過去タスク・issueの参照（IMPORTANT）

現在のタスクに関連する過去の情報を検索し、参照する:

1. **memories/（インデックス層）を検索**（推奨）
   ```bash
   # サマリーからキーワード検索
   rg "^summary:.*<キーワード>" ${MEMORY_DIR}/memories/ --no-ignore --hidden -i

   # タグ検索
   rg "^tags:.*<キーワード>" ${MEMORY_DIR}/memories/ --no-ignore --hidden -i

   # 該当するメモリを読み、relatedから詳細ログを参照
   ```

2. **過去のメモリディレクトリを検索**（memories/で見つからない場合）
   ```bash
   # 関連キーワードでディレクトリ名を検索
   ls ${MEMORY_DIR}/memory/ | grep -i "<キーワード>"

   # または全ディレクトリを確認
   ls -la ${MEMORY_DIR}/memory/
   ```

3. **関連する過去タスクのログを確認**
   - memories/のrelatedから、または直接memory/ディレクトリの`05_log.md`を読む
   - 過去の調査結果、決定事項、発生した問題を把握
   - 同じ問題を繰り返さない

4. **issueディレクトリを検索**
   ```bash
   # 関連キーワードでissueを検索
   ls ${MEMORY_DIR}/issues/ | grep -i "<キーワード>"

   # または優先度でフィルタ
   ls ${MEMORY_DIR}/issues/ | grep "^high-"
   ```

5. **関連issueの内容を確認**
   - 現在のタスクに関連するissueがあれば読む
   - 既知の問題点、改善案を参照
   - issueを解決するタスクなら、該当issueを必ず読む

6. **参照結果を05_log.mdに記録**
   ```markdown
   ## 過去タスク・issue参照

   ### 関連する過去タスク
   - YYMMDD_<task_name>: <関連内容の要約>

   ### 関連するissue
   - <issue名>: <関連内容の要約>

   ### 活用する知見
   - <過去の調査結果や決定事項>
   ```

**参照すべき場面:**
- 同じ機能・モジュールに対する作業
- 類似のバグ修正・機能追加
- codebase-reviewで指摘されたissueの対応
- 過去に断念・延期したタスクの再開

**→ 参照結果を05_log.mdに記録**

### 1.1 既存コードベースの調査

**大規模・未知のコードベースの場合**: `exploring-codebase`スキルを使用し、3つの並列Exploreサブエージェント（Architecture Explorer / Data Flow Tracer / Dependency Mapper）で多角的に調査する。

**通常の調査**:
- 関連コードをすべて特定・読解
- 設計パターン、命名規則、ディレクトリ構成を把握
- 変更の影響範囲を特定

**→ 発見した内容を05_log.mdに記録**

### 1.2 ベストプラクティスの調査

外部情報参照は必須（最低1回）。用途に応じてツールを使い分ける:

| ツール | 用途 | 例 |
|--------|------|-----|
| **Context7** | ライブラリ/フレームワークの最新ドキュメント | React, Prisma, Tailwind等のAPI参照 |
| **deepwiki** | リポジトリの設計・アーキテクチャ理解 | OSSの実装詳細、コード例 |
| **WebSearch** | 一般的な技術情報、ブログ記事 | ベストプラクティス、比較記事 |

**Context7の使用手順:**
1. `resolve-library-id`でライブラリIDを取得（例: `react` → `/facebook/react`）
2. `query-docs`でドキュメントを取得

**→ 参照結果を05_log.mdに記録**

### 1.3 実装方針の決定
- 複数選択肢がある場合はpros/consを整理
- 既存コードとの整合性を最優先
- **→ 選択理由を05_log.mdに記録**

### 1.3.1 大規模移行・メジャーバージョンアップ時の追加調査（IMPORTANT）

ライブラリのメジャーバージョンアップや大規模移行を行う場合、通常の調査に加えて以下を実施:

#### Step 1: Breaking Changesの網羅的整理

1. **公式マイグレーションガイドを熟読**
   - Context7 query-docs: "migration guide" / "breaking changes"
   - deepwiki: リポジトリのCHANGELOGやdiscussions
   - GitHub Issues: `label:migration` / `label:breaking-change`

2. **影響範囲マトリックスの作成**
   ```markdown
   | Breaking Change | 検出コマンド | 影響ファイル数 | 対応方針 |
   |----------------|-------------|--------------|---------|
   | API名変更 | `grep -r "旧API名" src/` | N件 | 一括置換 |
   | 新しい必須設定 | - | 設定ファイル | 手動追加 |
   ```

3. **影響ファイルの自動検出**（grepで事前にリストアップ）

#### Step 2: PoC（Proof of Concept）先行

**CRITICAL: いきなり全体移行しない。最小構成で動作確認を先に行う。**

1. 最小限の構成（コンポーネント0個、モデル1個等）で新バージョンを動かす
2. 発生するエラーと解決策を記録
3. 解決パターンが確立されてから全体移行に進む

#### Step 3: 段階的移行

1. カテゴリごとに分割（例: import変更 → 設定変更 → API変更）
2. 各カテゴリ完了後にコミット＋動作確認
3. 問題発生時にrevert可能な粒度を維持

### 1.4 GO/NO-GO検証ゲート（IMPORTANT）

調査完了後、実装に進む前に実現可能性を評価する。

**評価項目:**
| 項目 | 確認内容 |
|------|---------|
| 技術的実現可能性 | 既存アーキテクチャで実現可能か |
| 工数見積もり | 想定工数は妥当か |
| リスク | 重大なリスクはないか |
| 依存関係 | ブロッカーはないか |

**判定:**
| 判定 | 意味 | 次のアクション |
|------|------|---------------|
| **GO** | 実現可能、リスク許容範囲 | Phase 2に進む |
| **CONDITIONAL** | 条件付きで進行可 | 条件を明記してPhase 2に進む |
| **NO-GO** | 実現困難またはリスク過大 | ユーザーに報告、代替案を提示 |
| **DEFER** | 情報不足、依存待ち | 不足情報を明記、後日再評価 |

**出力形式:**
```markdown
## GO/NO-GO評価

### 判定: [GO/CONDITIONAL/NO-GO/DEFER]

### 評価結果
| 項目 | 評価 | 備考 |
|------|------|------|
| 技術的実現可能性 | ○/△/× | ... |
| 工数見積もり | ○/△/× | ... |
| リスク | ○/△/× | ... |
| 依存関係 | ○/△/× | ... |

### 理由
[判定理由を記載]

### 条件・注意事項（CONDITIONALの場合）
[進行条件を記載]
```

**→ 評価結果を05_log.mdに記録し、ユーザーに報告**

## Phase 2: 計画

4ステップ構造でタスクを作成:

```
### Task N: <タスク名>
**変更対象ファイル:** <パス>

#### 1. 調査
- [ ] 確認すべき既存コード
- [ ] 参照すべき外部情報

#### 2. 計画
- [ ] 詳細な実装手順
- [ ] 依存関係の確認

#### 3. 実行
- [ ] 実装内容
- [ ] コミット: `<メッセージ>`

#### 4. レビュー
- [ ] 計画通りか確認
- [ ] 整合性確認
- [ ] 型チェック・lint確認
```

### サブエージェントによる計画検証（ループ）

計画完了後、ユーザーに提示する前に専門サブエージェントでレビューを実施。

**CRITICAL: `agent`や`claude` CLIコマンドは使わない。Taskツールの専門サブエージェントを並列起動すること。**

**実行方法**:
Taskツールで以下のサブエージェントを並列起動:
- `arch-reviewer`: アーキテクチャ観点（レイヤー依存、責務分離、既存パターン整合性）
- `security-reviewer`: セキュリティ観点（認証認可、入力検証、機密情報）
- `perf-reviewer`: パフォーマンス観点（N+1、メモリ、アルゴリズム効率）

各サブエージェントにはレビュー対象ファイルのフルパスと、メモリディレクトリ内の計画ファイルのパスを渡す。

**ループ条件**:
1. サブエージェント並列レビュー実行
2. 「絶対にやるべき」指摘は必ず修正
3. それ以外の指摘はやる/やらない判断、または AskUserQuestion で確認
4. 修正後、再度サブエージェントレビューを実行（必要な観点のみ）
5. 修正すべき点がなくなるまで繰り返し
6. 完了したらユーザーに計画を提示

### User Validation Gate

計画をユーザーに提示し、承認を得る:

```markdown
## 計画承認依頼

### 実装計画サマリー
[タスク一覧と概要]

### 確認事項
- [ ] 要件を満たしているか
- [ ] 工数は妥当か
- [ ] リスクは許容範囲か

### 承認をお願いします
PASS / CONDITIONAL PASS / FAIL
```

**→ AskUserQuestionで承認を得てからPhase 3に進む**

## Phase 3: 実装

- 各タスクを「調査→計画→実行→レビュー」の順で実行
- **IMPORTANT: 品質チェック（format/lint/typecheck）は実装中にこまめに実行**
  - ファイル編集後、コミット前に必ず実行
  - エラーがあれば即座に修正
- **IMPORTANT: コミットはこまめに（高頻度で）打つ**
  - 1つの機能・修正が完了したら即座にコミット
  - 大きな変更を溜め込まない
- コミット: git-cz形式、意味的に独立した単位ごと
- コメント: Whyのみ記載
- docstring/jsdoc: 既存形式に従う

### Agent Teams活用（超大規模タスク向け）

**CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1** が有効な場合、以下の条件でAgent Teamsを検討:

**使用条件:**
- 10個以上の独立したファイル/モジュールの同時変更
- 複数の観点からの並列探索が必要
- 大規模なマイグレーション作業
- コストより速度を優先する場合

**使用しない場合:**
- 依存関係が強いタスク（順次実行が必要）
- 小〜中規模のタスク（サブエージェントで十分）
- コスト制約が厳しい場合（N人チーム = 約N倍のトークン消費）

**Agent Teams vs サブエージェント:**
| 観点 | Agent Teams | サブエージェント（Task） |
|------|------------|----------------------|
| 適用 | 超大規模（10+ファイル） | 小〜中規模（1-10ファイル） |
| コスト | 高（N倍） | 通常 |
| 独立性 | 完全独立、直接通信可 | 親に結果を返すのみ |

詳細: @skills/agent-teams/SKILL.md

### 実装中のUser Validation（大規模タスク向け）

10個以上のタスクがある場合、3-5タスクごとに中間報告:

```markdown
## 中間進捗報告

### 完了タスク
- [x] Task 1: ...
- [x] Task 2: ...

### 次のバッチ
- [ ] Task 3: ...
- [ ] Task 4: ...

### 問題・懸念
[あれば記載]

### 続行してよいですか？
```

**→ ユーザー確認後、次のバッチに進む**

## Phase 4: 品質確認

### 自動チェック
PJ CLAUDE.mdに記載のコマンドで実行:
- lint
- format
- typecheck
- test

### サブエージェント並列レビュー（ループ）
実装完了後、専門サブエージェントで並列レビュー。

**CRITICAL: `agent`や`claude` CLIコマンドは使わない。Taskツールの専門サブエージェントを並列起動すること。**

**実行方法**:
Taskツールで以下のサブエージェントを並列起動（変更内容に応じて選択）:
- `security-reviewer`: セキュリティ観点（認証認可、入力検証、機密情報露出）
- `perf-reviewer`: パフォーマンス観点（N+1、メモリリーク、アルゴリズム効率）
- `arch-reviewer`: アーキテクチャ観点（レイヤー依存、責務分離、既存パターン整合性）

各サブエージェントには変更対象ファイルのフルパスとレビュー観点を明示する。
メモリディレクトリのパスも含め、コンテキストを十分に提供する。

**ループ条件**:
1. サブエージェント並列レビュー実行
2. 「絶対にやるべき」指摘は必ず修正
3. それ以外の指摘はやる/やらない判断、または AskUserQuestion で確認
4. 修正後、再度サブエージェントレビューを実行（必要な観点のみ）
5. 修正すべき点がなくなるまで繰り返し
6. 完了したらPhase 5へ

### pre-pr-interrogation（厳格レビューオプション）

ユーザーが「質問攻めにして」「テストに合格するまでPRは作らないで」と依頼した場合、または重要な変更でより厳格なレビューが必要な場合は、`pre-pr-interrogation`スキルを使用。

詳細: @skills/pre-pr-interrogation/SKILL.md

**通常のagent reviewとの違い:**
| 観点 | agent review | pre-pr-interrogation |
|------|--------------|---------------------|
| 形式 | 指摘→修正 | 質問攻め→合格判定 |
| 厳格さ | 標準 | 高（全質問に合格必須） |
| 用途 | 通常の品質確認 | 重要変更、セキュリティ関連 |

## Phase 4.5: セッション終了前チェック（推奨）

コード変更を伴うタスクの場合、Phase 5の前に以下を検討:

### /techdebt（重複コード検出）

セッション中に追加・変更したコードに重複がないか確認:

```
/techdebt --scope session
```

**実行推奨の場面:**
- 新規機能を複数ファイルに実装した場合
- 既存コードをコピー&修正した場合
- 「とりあえず動く」実装をした場合

**スキップ可能な場面:**
- 単純なバグ修正
- 設定変更のみ
- ドキュメント更新のみ

詳細: @skills/techdebt/SKILL.md

## Phase 5: 完了報告

1. 実装内容の概要
2. 自律決定した事項
3. 作成したブランチ名
4. 残存する課題
5. **価値ある知見があれば memories/ にインデックスを作成**
   - `${MEMORY_DIR}/memories/<category>/<topic>.md` に保存
   - `related` フィールドで memory/ の詳細ログを参照
   - フォーマット: @context/memory-file-formats.md

## ユーザーへの質問

- 質問・確認が必要な場合は**必ずAskUserQuestionツールを使用**
- 必要なタイミングで躊躇なく積極的に質問する
- 曖昧な点は推測せず確認する

## 禁止事項

- 計画なしで実装開始
- 4ステップ構造の省略
- 外部情報を参照せずに実装方針決定
- 品質チェックのスキップ
- **05_log.mdを更新せずに次のPhaseに進むこと**
- **agent reviewを実行せずに完了報告すること**
- **システムプロンプト（Plan mode等）のワークフローをこのファイルより優先すること**

## 「後回し」「実装しない」判断時のルール

- 完全に禁止ではないが、判断には理由と記録が必須
- `99_history.md`に以下を記録:
  - 判断理由
  - 代替案（あれば）
  - 再開条件（いつ実装すべきか）
- 依存待ち・情報不足・明確なスコープ外の場合のみ許容
