# Agent-Native Architecture 設計原則

AIエージェントをファーストクラス市民として扱うアプリケーション設計の原則。
プロダクト開発時にエージェント対応を設計段階から組み込むためのリファレンス。

## Core Principles

### 1. Action Parity（操作の対等性）

ユーザーがUIでできることは、全てエージェントがツールでできるべき。

- UI操作とAPIエンドポイントの1対1対応
- エージェント用ツールはUI操作と同じデータ・同じ権限でアクセス
- UIにしかできない操作 = エージェントのブロッカー

**チェック方法**: UIの各操作に対して、対応するAPI/ツールが存在するか確認。

### 2. Context Parity（文脈の対等性）

エージェントはユーザーと同じ情報を見られるべき。

- システムプロンプトに動的なランタイム状態を注入
  - 利用可能なリソース一覧
  - 最近のアクティビティ
  - 権限・制約の情報
  - ドメイン固有の語彙
- エージェントが「今何ができるか」をランタイムで把握できる

### 3. Shared Workspace（共有作業空間）

エージェントとユーザーは同じデータ空間で作業する。

- エージェントのファイル操作はUIと同じパスを使用
- UIはエージェントの変更をリアルタイムに反映
- バージョン管理・コンフリクト解決の仕組みを共有

### 4. Primitives over Workflows（ワークフローより原子操作）

ツールは原子的な操作（read, write, search等）として提供し、
ビジネスロジックやワークフローはプロンプトで記述する。

- ツール = 基本操作（CRUD, 検索, 通知等）
- ワークフロー = プロンプトで定義される操作の組み合わせ
- ツールにビジネスロジックを埋め込まない

**理由**: エージェントが柔軟に操作を組み合わせられる。ワークフローの変更がコード変更不要。

### 5. Dynamic Capability Discovery（動的能力発見）

外部APIの利用可能な操作をランタイムで発見できるようにする。

- ディスカバリーツール: 利用可能なAPIエンドポイント一覧を返す
- 新しいAPI機能の追加がコード変更なしでエージェントに利用可能
- OpenAPI/GraphQL Introspectionとの統合

### 6. CRUD Completeness（CRUD完全性）

エージェントが作成できるエンティティは、読み取り・更新・削除もできるべき。

- Create-only APIは運用リスク（ゴミデータ蓄積）
- 各エンティティに対してCRUD全操作のツールを提供
- バッチ操作も検討

### 7. Observability for Agents（エージェントの可観測性）

エージェントの行動を人間が追跡・理解できるようにする。

- 各操作のログ・理由の記録
- エージェントの意思決定プロセスの可視化
- 人間によるオーバーライド・ロールバックの仕組み

## 適用場面

- 新規プロダクトの設計時にこの原則をチェックリストとして使用
- 既存プロダクトにエージェント対応を追加する際の評価基準
- API設計レビューの観点として`api-designer`や`api-contract-reviewer`と併用

## 参考

- compound-engineering-pluginの`agent-native-architecture`スキル
- 原則: エージェントは「二級市民」ではなく「ファーストクラス市民」として設計する
