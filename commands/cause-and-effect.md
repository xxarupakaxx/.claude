---
description: Systematic Fishbone analysis exploring problem causes across six categories
argument-hint: 分析する問題の説明（オプション）
---

# 原因と結果の分析（特性要因図）

フィッシュボーン（石川）ダイアグラム分析を適用し、複数のカテゴリにわたって問題の潜在的原因を体系的に探索する。

## 説明

6つのカテゴリにわたって潜在的原因を体系的に検証: 人、プロセス、技術、環境、方法、材料。寄与要因を特定する構造化された「魚の骨」ビューを作成。

## 使用方法

`/cause-and-effect [問題の説明]`

## 変数

- PROBLEM: 分析する問題（デフォルト: 入力を促す）
- CATEGORIES: 探索するカテゴリ（デフォルト: 全6つ）

## 手順

1. 問題を明確に述べる（魚の「頭」）
2. 各カテゴリについて、潜在的原因をブレインストーミング:
   - **人**: スキル、トレーニング、コミュニケーション、チームダイナミクス
   - **プロセス**: ワークフロー、手順、標準、レビュー
   - **技術**: ツール、インフラ、依存関係、設定
   - **環境**: ワークスペース、デプロイ先、外部要因
   - **方法**: アプローチ、パターン、アーキテクチャ、プラクティス
   - **材料**: データ、依存関係、サードパーティサービス、リソース
3. 各潜在的原因について「なぜ」を問いかけ、より深く掘り下げる
4. 寄与原因と根本原因を特定
5. 影響度と可能性で原因を優先順位付け
6. 最優先の原因に対する解決策を提案

## 例

### 例1: APIレスポンス遅延

```
問題: APIレスポンスが3秒以上かかる（目標: <500ms）

人
├─ チームがパフォーマンス最適化に不慣れ
├─ パフォーマンス監視の担当者がいない
└─ フロントエンドチームがバックエンドの制約を理解していない

プロセス
├─ CI/CDにパフォーマンステストがない
├─ レスポンスタイムのSLAが未定義
└─ コードレビューでパフォーマンス劣化が検出されない

技術
├─ データベースクエリが最適化されていない
│  └─ なぜ: クエリ分析ツールが導入されていない
├─ ORMでN+1クエリ
│  └─ なぜ: Eagerロードが設定されていない
├─ キャッシング層がない
│  └─ なぜ: Redisが技術スタックにない
└─ 外部APIコールが同期的
   └─ なぜ: 非同期アーキテクチャが導入されていない

環境
├─ 本番環境のデータベースインスタンスが必要より小さい
├─ 静的アセット用のCDNがない
└─ 単一リージョンデプロイ（遠方のユーザーに高レイテンシ）

方法
├─ REST API設計が複数回のラウンドトリップを必要とする
├─ 大規模データセットにページネーションがない
└─ 選択的フィールドではなくフルオブジェクトシリアライゼーション

材料
├─ 大きなJSONペイロード（不要なデータ）
├─ レスポンスが非圧縮
└─ サードパーティAPI（決済ゲートウェイ）が遅い
   └─ なぜ: レート制限のある無料プラン

根本原因:
- パフォーマンス要件が定義されていない（プロセス）
- パフォーマンス監視ツールがない（技術）
- アーキテクチャがキャッシング/非同期をサポートしていない（方法）

解決策（優先順位順）:
1. データベースインデックスを追加（クイックウィン、高インパクト）
2. Redisキャッシング層を実装（中程度の工数、高インパクト）
3. 外部APIコールをwebhookで非同期化（高工数、高インパクト）
4. パフォーマンスSLAを定義・監視（低工数、リグレッション防止）
```

### 例2: フレーキーテストスイート

```
問題: テスト実行の15%が失敗し、リトライで成功

人
├─ チーム間でテスト作成スキルにばらつき
├─ 新しい開発者が既存のフレーキーパターンをコピー
└─ フレーキーテスト修正の担当者がいない

プロセス
├─ フレーキーテストが「既知の問題」としてマークされ無視される
├─ フレーキーテストがあってもマージを許可するポリシー
└─ テスト失敗がデプロイをブロックしない

技術
├─ 非同期テストセットアップで競合状態
├─ テストがグローバル状態を共有
├─ テストデータベースがテストごとに分離されていない
├─ 適切な待機の代わりにsetTimeoutを使用
└─ CI環境が不安定（CPU/メモリが異なる）

環境
├─ CIランナーが高負荷
├─ ネットワークタイミングが変動（外部APIモックがフレーキー）
└─ ローカルとCI間でタイムゾーンの違い

方法
├─ 統合テストが適切に分離されていない
├─ 正当なタイミング問題に対するリトライロジックがない
└─ テストが実行順序に依存

材料
├─ テストデータフィクスチャが重複
├─ 共有テストデータベースが汚染
└─ モックデータが本番パターンと一致しない

根本原因:
- テスト分離戦略がない（方法 + 技術）
- プロセスがフレーキーテストを許容（プロセス）
- 非同期タイミングが適切に処理されていない（技術）

解決策:
1. テストごとのデータベース分離を実装（高インパクト）
2. setTimeoutを適切なasync/awaitパターンに置き換え（中インパクト）
3. フレーキーテストパターンをブロックするpre-commitフックを追加（新規問題防止）
4. ポリシー強制: フレーキーテスト = マージブロック（プロセス変更）
```

### 例3: 機能が3週間ではなく3ヶ月かかった

```
問題: シンプルなCRUD機能が見積もり3週間に対し12週間かかった

人
├─ 開発者がコードベースに不慣れ
├─ 重要なフェーズ中にキーアーキテクトが休暇
└─ デザイナーが開発途中で要件を変更

プロセス
├─ 開始前に要件が確定していない
├─ 最初の6週間コードレビューなし（大きなdiff）
├─ デザイン修正が複数回
└─ QAが遅れて開始（10週目に問題発見）

技術
├─ コードベースの結合度が高い（変更の波及効果）
├─ 自動テストがない（手動テストが遅い）
├─ レガシーコードが先にリファクタリング必要
└─ 開発環境セットアップに2週間

環境
├─ ステージング環境が3週間壊れていた
├─ テストに本番データが必要（コンプライアンス遅延）
└─ 別チームによる依存関係がブロック

方法
├─ インクリメンタルデリバリーなし（ビッグバンアプローチ）
├─ 過剰エンジニアリング（「ついでに」将来の機能を追加）
└─ 設計ドキュメントなし（実装中に問題発見）

材料
├─ サードパーティAPIが開発中に変更
├─ 本番データモデルがステージングと異なる
└─ デザインアセットがない（デザイナー待ち）

根本原因:
- 開始前の要件ロックダウンがない（プロセス）
- アーキテクチャがインクリメンタルな変更を妨げる（技術）
- 反復的ではなくビッグバンアプローチ（方法）
- 開発環境が自動化されていない（技術）

解決策:
1. 開始前に設計ドキュメント + 確定要件を必須に（プロセス）
2. インクリメンタルデリバリー用のフィーチャーフラグを実装（方法）
3. 開発環境セットアップを自動化（技術）
4. 高結合エリアをリファクタリング（技術、長期）
```

## 注意事項

- フィッシュボーンは複数ドメインにわたるシステム的問題を明らかにする
- 複数の原因が組み合わさって問題を引き起こすことが多い
- 各カテゴリの最初の原因で止まらない—より深く掘り下げる
- 一部の原因は複数のカテゴリにまたがる（マークする）
- 根本原因は通常プロセスまたは方法にある（技術だけでなく）
- 特定の原因をより深く分析するには`/why`コマンドを使用
- 解決策の優先順位: インパクト × 実現可能性 ÷ 工数
- 症状ではなく根本原因に対処
